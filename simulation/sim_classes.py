from random import randint, choice


class City:
    def __init__(self):
        """
        The city class contains Agents and Stations, and has a time attribute.
        Whenever time elapses, User Agents (with destinations) may be generated at Stations.
        Stations must have a distinct st_id.
        """
        self._stations = dict()
        self._agents = []
        self._time = 0
        # It may make sense to create a class that logs data. For now, keeping simple with lists
        self._failed_starts = []
        self._failed_ends = []
        self._finished_journeys = []

    def move_agents(self, t):
        """Existing agents proceed with their journeys, potentially arriving at their destination.
        Agents handle their own .arrival() logic as part of travel()
        In simulation conditions this is called by main_elapse_time()"""
        for agent in self._agents:
            agent.travel(t)
        self.cleanup_agents()  # agents should not remove themselves whilst elapse_time is iterating over _agents

    def request_demand(self, t):
        """City asks stations to decide what journeys will originate at them, and will attempt to generate any
        requested journeys.
        In simulation conditions this is called by main_elapse_time()"""
        # Stations now generate demand for more journeys
        for station in self._stations.values():
            journey_demand = station.decide_journey_demand(t)
            for j in journey_demand:
                self.generate_journey(*j)

    def main_elapse_time(self, t=1):
        """
        This is where the bulk of simulation behaviour takes place.
        The phases are:
            1. Existing agents travel(), during which they will handle their own arrival logic if they arrive at a dest.
                City cleans-up any agents who have flagged themselves as finished (i.e. arrived)
            2. Stations decide what journeys (if any) they will request. They return journey parameters and City
                will attempt to generate those journeys
            3. Agents in need of a new destination decide on their next destination

        This order was chosen to try and maximise the useful context available to objects when they perform their
        actions.
        """
        self._time += t
        self.move_agents(t)
        self.request_demand(t)
        # agents now decide their next destination if required
        for agent in self._agents:
            if agent.need_new_destination:
                agent.determine_next_destination()

    def generate_journey(self, start_st, dest_st, duration:int):
        """
        Given:
            - A starting station
            - A destination station
            - A journey duration
        This method will attempt to generate a journey.

        If the starting station is empty, the journey will count as a failed start immediately. An Agent will
        not be instantiated in this case (as they could not even begin their journey).

        If the starting station is not empty, an Agent will be instantiated and undock a bike from the Station.

        Note: the 'demand' for journeys is generated by the stations themselves: the stations ask City
        to generate journeys on their behalf. As part of City.request_demand()
        :return:
        """
        if start_st.is_empty():
            self.log_failed_start()
        else:
            u = User(self, dest_st, duration)
            self._agents.append(u)
            u.undock_bike(start_st)

    def cleanup_agents(self):
        """remove agents from the city if they are finished"""
        self._agents = [a for a in self._agents if not a.finished]

    def add_station(self, s):
        """
        Assigns a station object to the city by adding it to City._stations. This simultaneously adds the city as
        the station's ._city attribute.
        :param s:
        :return:
        """
        key = s.get_id()

        if key in self._stations:
            raise ValueError(f"Station with ID {key} is already in city")

        self._stations[key] = s
        s._city = self

    def get_station(self, key):
        return self._stations[key]

    def log_failed_end(self):
        self._failed_ends.append(self._time)

    def log_failed_start(self):
        self._failed_starts.append(self._time)

    def log_finished_journey(self):
        self._finished_journeys.append(self._time)


class Station:
    def __init__(self, capacity=None, docked_init=None, st_id=None):
        """
        A Station that can receive or release bikes, e.g. bikepoint or depot.
        capacity: total number of docks.
        docked_init: number of bikes docked when Station is instantiated
        st_id: an identifier that will be used to locate the Station when it is added to a City object

        :param capacity: int
        :param docked_init: int
        :param st_id: int
        """
        if capacity < 1:
            raise ValueError(f"Capacity must be at least 1. {capacity} was given")
        if docked_init < 0 or docked_init > capacity:
            raise ValueError(f"docked_init must be between 0 and capacity. {docked_init} was given")

        self._capacity = capacity
        self._docked = docked_init
        self._id = st_id
        self._city = None

    def is_empty(self):
        return self._docked == 0

    def is_full(self):
        return self._docked == self._capacity

    def give_bike(self):
        """If the station is not empty, undocks a bike and returns true"""
        if not self.is_empty():
            self._docked -= 1
            return True
        else:
            raise Exception('Bike underflow occurred')

    def take_bike(self):
        """If the station is not full, docks a bike and returns false"""
        if not self.is_full():
            self._docked += 1
            return True
        else:
            raise Exception('Bike overflow occurred')

    def get_id(self):
        return self._id

    def decide_journey_demand(self, t):
        """
        The station will decide what journeys will start at it during the elapsing time period, including destinations
        and durations, and return their parameters.

        It returns a list of (self, dest_st, duration) tuples.
        """
        # TODO: Replace Dummy logic with realistic demand. Right now station picks random destination, possibly itself
        journey_demand = []
        for i in range(randint(0, 3*t)):
            destination = choice(self._city._stations)
            duration = randint(1, 5)
            journey_demand.append((self, destination, duration))
        return journey_demand


class Agent:
    def __init__(self, city: City, destination: Station, duration: int):
        """This is the parent class / interface for Users and Trucks"""
        self._current_destination = destination
        self._remaining_duration = duration
        self._city = city
        self.finished = False
        self.need_new_destination = False

    def dock_bike(self):
        pass

    def undock_bike(self, station:Station):
        pass

    def determine_next_destination(self):
        # TODO: ASSIGN NEW STATION TO self._current_destination
        self.need_new_destination = False

    def arrival(self):
        pass

    def travel(self, t):
        """Reduces remaining duration and calls Agent.arrival() if user has arrived"""
        self._remaining_duration -= t
        if self._remaining_duration < 0.5:  # TODO: check you are happy with this condition
            self.arrival()


class User(Agent):
    def arrival(self):
        """Overrides arrival with User behaviour"""
        if self._current_destination.is_full():
            self._city.log_failed_end()
            self.need_new_destination = True
        else:
            self.dock_bike()

    def dock_bike(self):
        """A user is removed after docking a bike sucessfully"""
        self._current_destination.take_bike()
        self.finished = True
        self._city.log_finished_journey()

    def undock_bike(self, station: Station):
        station.give_bike()