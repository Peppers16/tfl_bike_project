from pandas import DataFrame

from tfl_project.simulation.station import Station


class City:
    def __init__(self, interval_size=20):
        """
        The city class contains Agents and Stations, and has a time attribute.
        Whenever time elapses, User Agents (with destinations) may be generated at Stations.
        Stations must have a distinct st_id.

        The interval_size is a meta parameter that remembers the size of time interval that the station data is
        collected for. I.e. if interval = 20, then station demand will be grouped into 20-minute chunks.
        The simulation is not restricted to this interval.
        """
        self._stations = dict()
        self._agents = []
        self._time = 0
        self._interval_size = interval_size
        self._event_log = dict(
            time_series=dict(time=[0], failed_starts=[0], failed_ends=[0], finished_journeys=[0])
            , totals=dict(failed_starts=0, failed_ends=0, finished_journeys=0)
            , events=dict(time=[], start_st=[], end_st=[], orig_start_st=[], orig_end_st=[], event=[])
        )

    def timeseries_log_append_t(self):
        """the time_series component of the event long is a dictionary of lists, which will easily convert to a
        DataFrame. Each t period the list must be extended"""
        self._event_log['time_series']['time'].append(self._time)
        self._event_log['time_series']['failed_starts'].append(0)
        self._event_log['time_series']['failed_ends'].append(0)
        self._event_log['time_series']['finished_journeys'].append(0)

    def move_agents(self, t):
        """Existing agents proceed with their journeys, potentially arriving at their destination.
        Agents handle their own .arrival() logic as part of travel()
        In simulation conditions this is called by main_elapse_time()"""
        for agent in self._agents:
            agent.travel(t)
        self.cleanup_agents()  # agents should not remove themselves whilst elapse_time is iterating over _agents

    def request_demand(self, interval, t):
        """City asks stations to decide what journeys will originate at them, and will attempt to generate any
        requested journeys.
        In simulation conditions this is called by main_elapse_time()
        :param interval: the current time interval that the simulation is in.
        :param t: the number of minutes that are elapsing during this 'round'
        """
        # Stations now generate demand for more journeys
        for station in self._stations.values():
            journey_demand = station.decide_journey_demand(interval=interval, elapsing=t)
            for j in journey_demand:
                self.generate_journey(*j)

    def call_for_new_destinations(self):
        """Simply instructs all agents to assign themselves a new destination if they need one"""
        for agent in self._agents:
            if agent.need_new_destination:
                agent.determine_next_destination()

    def main_elapse_time(self, t=1):
        """
        This is where the bulk of simulation behaviour takes place.
        The phases are:
            1. Existing agents travel(), during which they will handle their own arrival logic if they arrive at a dest.
                City cleans-up any agents who have flagged themselves as finished (i.e. arrived)
            2. Stations decide what journeys (if any) they will request. They return journey parameters and City
                will attempt to generate those journeys
            3. Agents in need of a new destination decide on their next destination

        This order was chosen to try and maximise the useful context available to objects when they perform their
        actions.
        """
        if self._time != 0:
            self.timeseries_log_append_t()
        current_interval = (self._time // self._interval_size) * self._interval_size
        self.move_agents(t)
        self.request_demand(interval=current_interval, t=t)
        self.call_for_new_destinations()
        self._time += t

    def generate_journey(self, start_st, dest_st, duration:int):
        """
        Given:
            - A starting station
            - A destination station
            - A journey duration
        This method will attempt to generate a journey.

        If the starting station is empty, the journey will count as a failed start immediately. An Agent will
        not be instantiated in this case (as they could not even begin their journey).

        If the starting station is not empty, an Agent will be instantiated and undock a bike from the Station.

        Note: the 'demand' for journeys is generated by the stations themselves: the stations ask City
        to generate journeys on their behalf. As part of City.request_demand()
        :return:
        """
        if start_st.is_empty():
            self.log_failed_start(start_st=start_st, end_st=dest_st, orig_start_st=start_st, orig_end_st=dest_st)
        else:
            u = User(self, dest_st, duration, start_st=start_st)
            self._agents.append(u)
            u.undock_bike(start_st)

    def cleanup_agents(self):
        """remove agents from the city if they are finished"""
        self._agents = [a for a in self._agents if not a.finished]

    def add_station(self, s):
        """
        Assigns a station object to the city by adding it to City._stations. This simultaneously adds the city as
        the station's ._city attribute.
        :param s:
        :return:
        """
        key = s.get_id()

        if key in self._stations:
            raise ValueError(f"Station with ID {key} is already in city")

        self._stations[key] = s
        s._city = self

    def get_station(self, key):
        return self._stations[key]

    def log_event(self, event_key, start_st, end_st, orig_start_st, orig_end_st):
        self._event_log['totals'][event_key] += 1
        self._event_log['time_series'][event_key][-1] += 1
        self._event_log['events']['time'].append(self._time)
        self._event_log['events']['start_st'].append(start_st.get_id())
        self._event_log['events']['end_st'].append(end_st.get_id())
        self._event_log['events']['event'].append(event_key)
        self._event_log['events']['orig_start_st'].append(orig_start_st.get_id())
        self._event_log['events']['orig_end_st'].append(orig_end_st.get_id())

    def log_failed_end(self, start_st, end_st, orig_start_st, orig_end_st):
        self.log_event('failed_ends', start_st, end_st, orig_start_st, orig_end_st)

    def log_failed_start(self, start_st, end_st, orig_start_st, orig_end_st):
        self.log_event('failed_starts', start_st, end_st, orig_start_st, orig_end_st)

    def log_finished_journey(self, start_st, end_st, orig_start_st, orig_end_st):
        self.log_event('finished_journeys', start_st, end_st, orig_start_st, orig_end_st)

    def get_timeseries_df(self):
        return DataFrame.from_dict(self._event_log['time_series'])

    def get_events_df(self):
        return DataFrame.from_dict(self._event_log['events'])


class Agent:
    def __init__(self, city: City, destination: Station, duration: int, start_st):
        """This is the parent class / interface for Users and Trucks"""
        self._current_destination = destination
        self._last_departed_station = start_st
        self._remaining_duration = duration
        self._city = city
        self.finished = False
        self.need_new_destination = False

    def dock_bike(self):
        pass

    def undock_bike(self, station: Station):
        pass

    def determine_next_destination(self):
        candidates = [st for st in self._city._stations.values() if not st.is_full()]
        candidates.sort(
            key=lambda x: x.distance_from(self._current_destination)
        )
        new_destination = candidates[0]
        new_duration = self._current_destination.pick_duration(new_destination.get_id())
        self._last_departed_station = self._current_destination
        self._current_destination = new_destination
        self._remaining_duration = new_duration
        self.need_new_destination = False

    def arrival(self):
        pass

    def travel(self, t):
        """Reduces remaining duration and calls Agent.arrival() if user has arrived"""
        self._remaining_duration -= t
        if self._remaining_duration < 0.5:  # TODO: check you are happy with this condition
            self.arrival()


class User(Agent):

    def __init__(self, city, destination, duration, start_st):
        super().__init__(city, destination, duration, start_st)
        # Users remember their original departures and destinations, even if they encounter full stations
        self.original_start_st = start_st
        self.original_end_st = destination

    def arrival(self):
        """Overrides arrival with User behaviour"""
        if self._current_destination.is_full():
            self._city.log_failed_end(
                start_st=self._last_departed_station
                , end_st=self._current_destination
                , orig_start_st=self.original_start_st
                , orig_end_st=self.original_end_st
            )
            self.need_new_destination = True
        else:
            self.dock_bike()

    def dock_bike(self):
        """A user is removed after docking a bike successfully"""
        self._current_destination.take_bike()
        self.finished = True
        self._city.log_finished_journey(
                start_st=self._last_departed_station
                , end_st=self._current_destination
                , orig_start_st=self.original_start_st
                , orig_end_st=self.original_end_st
            )

    def undock_bike(self, station: Station):
        station.give_bike()
